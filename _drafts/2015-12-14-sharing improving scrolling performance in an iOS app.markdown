---
layout:       post
title:        Sharing experience from improving scrolling peformance on iOS UICollectionView in WeWork iOS app.
author:       amit_rao
summary:      Recently we improved the scrolling performance of the WeWork iOS app with the goal of getting as close to 60 fps consistently as possible. The blog post describes my experience solving the issue and adding to some of the existing resources. 
image:        http://res.cloudinary.com/wework/image/upload/v1450139297/engineering/perf_optimization_meme.jpg         
categories:   engineering
---

### What does optimizing scrolling performance mean and why is it important? 

Recently I spent some time optimizing the scrolling performance of a UICollectionView so that the scrolling is now 60 fps (frames per sec) and buttery smooth (iPhone 5/6/6s)  followed some hints on (http://www.raywenderlich.com/86365/asyncdisplaykit-tutorial-achieving-60-fps-scrolling) which links to a very good WWDC 2012 video on iOS app performance: graphics & animations. If you happen to run into these issues you might find these videos useful. In my case after running the Core Animation benchmark and baselining performance it turned out the issue was GPU bound and the renderer was doing a lot of work. The scrolling was visibly jittery and instruments showed 45 - 55 fps. After using the simulator and instruments to enable color blended layers it was clear that there were a number of CA layers being rendered.  Often in such cases UIImages can be the bottleneck. Either the images are being loaded  without using `imageNamed` or the resolution of the image is too high e.g. a large image being loaded into a thumbnail view.  What is interesting in the video is that the apple engineer recommends using the platforms built in caching support, async drawing support & flattening support before pulling out the heavy tools. It is also important to make sure one is reusing cells etc. In this case blending the layers in the various subviews of the `UICollectionViewCell` gave the most bang for the buck and was a solution we could live with. The general methodology is to determine if it a CPU or GPU bound issue. Come up with a theory and baseline, then make code changes and measure again. See if there is improvement and record all measurements. The WWDC video recommends some other tips worth checking out and  speculative caching is another powerful technique. You might want to check out `NSCache/NSPurgeable` esp. for images. Facebookâ€™s AsyncDisplayKit might be worth checking out especially if one is developing an app from scratch (We did not use it). 

To add re: image rendering- in addition to Debug > Color Blended Layers, you can use  Debug > Color Misaligned Images to show scaled images in yellow and misaligned images in magenta. your best bet for fast scrolling is no blending, no scaled images, no misaligned images, no shadows as long as product & design will sign off. 

To improve the thumbnail insertion, use NSCache/NSPurgeable for the thumbnail images. In other words, create the thumbnail on the fly and store the result in a cache (speculative caching) based on a key using the cell or record ID. Then the next time the image is needed, rather than recalculating/resizing you re-use the cached image. If it has been purged, you recalculate.  This is pretty straightforward and can be used for all scrolling which has a number of images which are expensive to either generate or retrieve. It is also what the Apple home screen uses for all the App Icons.

There is a WWDC video re: how Apple implemented the home screen scrolling and all of the parameters they had to consider such as cache size, memory usage vs cache usage, .... excellent video for understanding NSCache/NSPurgeable.
